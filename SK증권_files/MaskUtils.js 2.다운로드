/**
 * 참고사항) 커서 위치나 선택영역에 관계없이 항목 끝에 입력되도록 제한한다. (단, email 은 예외)
 *          <INPUT type="text" /> 만 적용가능하다.
 * Browsers: IE 10, 11, Latest Chrome
 * @file MASK Utils
 * @author youks@solupia.co.kr
 * @module _MASK
 */
(function (window, document) {
"use strict";
var pluginName = "_MASK";

if (!window.hasOwnProperty(pluginName) || null == window[pluginName]) window[pluginName] = (function (window, document) {
    // private property
    /**
     * @typedef {object} TYPES
     * @property {string} IP IP 주소: 숫자와 구분자(.)를 이용하여 0.0.0.0 ~ 255.255.255.255 사이의 값을 입력한다.
     * @property {string} MAC_ADDRESS MAC 주소: 숫자와 a ~ f 및 구분자(-:)를 이용하여 00-00-00-00-00-00 ~ FF-FF-FF-FF-FF-FF 사이의 값을 입력한다.
     * @property {string} PHONE_NUMBER 전화번호: 숫자를 이용하여 02-000-0000 ~ 02-9999-9999 또는 000-000-0000 ~ 999-9999-9999 사이의 값을 입력한다.
     * @property {string} EMAIL 전자메일주소: 한글 이외의 문자 및 구분자(@) 1개를 이용하여 입력한다.
     * @property {string} INTEGER 정수: 최대 15자리 정수를 입력한다. 또한, + 및 - 로 양수/음수 변환이 가능하고 up 및 down 으로 값의 증가/감소가 가능하다.
     * @property {string} CURRENCY 통화: 최대 15자리 금액을 입력한다. up 및 down 으로 값의 증가/감소가 가능하다.
     * @property {string} DECIMAL 소수: 최대 15자리 숫자와 소숫점을 입력한다. up 및 down 으로 값의 증가/감소가 가능하다.
     * @property {string} DATE 날짜: 숫자와 구분자(-)를 이용하여 1900-01-01 ~ 9999-12-31 사이의 값을 입력한다. up 및 down 으로 값의 증가/감소가 가능하다.
     * @property {string} USER_ID 사용자식별자: 알파벳 및 숫자를 이용하여 입력한다.
     * @property {string} DEFINED 지정문자: 지정된 문자를 이용하여 입력한다.
     * @description MASK 유형
     * @example <caption>HTML:</caption>
     * <input type="text" id="email1" />
     * @example <caption>JAVAScript:</caption>
     * var email1 = document.getElementById("email1");
     * _MASK.initialize(email1, _MASK.TYPES.EMAIL);
     */
    var __TYPES = {
        IP: "ip",
        MAC_ADDRESS: "mac",
        PHONE_NUMBER: "phone-number",
        EMAIL: "email",
        INTEGER: "integer",
        CURRENCY: "currency",
        DECIMAL: "decimal",
        DATE: "date",
        DATE_RANGE: "date-range",
        USER_ID: "user-id",
        DEFINED: "defined"
    };
    var __NAMES = {
        TYPE: "solupia-mask-type",
        MIN: "solupia-mask-min",
        MAX: "solupia-mask-max",
        STEP: "solupia-mask-step",
        FRACTION_DIGITS: "solupia-fraction-digits",
        DEFINED_CHARS: "solupia-defined-chars",
        DEFINED_CASE: "solupia-defined-case"
    };
    var __IS_NO_SELECT = false;

    var __macAddressDelimiter = 0; /* 0 -> - *//* 1 -> : */

    // BEGIN date range private method ----------
    var __DATE_RANGE_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly()     && ifChanged(aKeydown) && isExpectedInRange(aKeydown)) addDelimiterIfNeeded(aKeydown);
// TODO
console.log("COMING SOON - UNDER CONSTRUCTION : DATE RANGE");
            allowInputAtLast(aKeydown);
            // nested ----------
            function expectedDateFor(aKeydown) {
                if (isTrueThat(aKeydown).isUpKeyOnly()) {
                    if      (10 === currentValueFor(aKeydown).length) return addDays(currentValueFor(aKeydown), 1);
                    else if (23 === currentValueFor(aKeydown).length) return addDays(currentValueFor(aKeydown), 1);
                    else                                              return currentValueFor(aKeydown);
                } else
                if (isTrueThat(aKeydown).isDownKeyOnly()) {
                    if      (10 === currentValueFor(aKeydown).length) return addDays(currentValueFor(aKeydown), -1);
                    else if (23 === currentValueFor(aKeydown).length) return addDays(currentValueFor(aKeydown), -1);
                    else                                              return currentValueFor(aKeydown);
                } else {
                    return __DATE_MASK.format(__DATE_MASK.apply(currentValueFor(aKeydown) + stringFromKey(aKeydown)));
                }
            }
            function ifChanged(aKeydown) {return isRightThat(currentValueFor(aKeydown), _isNotEqualTo(expectedDateFor(aKeydown)));}
            function isExpectedInRange(aKeydown) {
                var dates = expectedDateFor(aKeydown).split(" ~ ");
                return (isTrueThat(dates[0               ]).isInRangeFor(aKeydown) &&
                        isTrueThat(dates[dates.length - 1]).isInRangeFor(aKeydown)
                       );
            }
            function addDelimiterIfNeeded(aKeydown) {
                if (isNeeded(aKeydown)) __getTextBox(aKeydown).value += "-";
                // nested ----------
                function isNeeded(aKeydown) {
// TODO
                    return __testRegExps([
                        /^(19|[2-9][0-9])[0-9]{2}$/, /* 1900~9999 */
                        /^(19|[2-9][0-9])[0-9]{2}-(0[1-9]|1[0-2])$/, /* 1900-01~9999-12 */
                    ], currentValueFor(aKeydown));
                }
            }
        },

        handleChangeEvent: function (aChange) {
            var slicedValue;
            var dates;

            for (var length = slicedValueFor(aChange, __DATE_RANGE_MASK.apply).length; length >= 1; length--) {
                slicedValue = slicedValueFor(aChange, __DATE_RANGE_MASK.apply, length);
                dates = slicedValue.split(" ~ ");
                if (isTrueThat(dates[0]).isInRangeFor(aChange) &&
                    isTrueThat(dates[dates.length - 1]).isInRangeFor(aChange)
                ) {
                    __getTextBox(aChange).value = __DATE_RANGE_MASK.format(slicedValue);
                    return;
                }
            }
            __getTextBox(aChange).value = "";
        },

        apply: function (input) {
            if (isDateRange(__DATE_RANGE_MASK.format(input))) return __DATE_RANGE_MASK.format(input);
            else                                              return extractValueFrom(input, isDateRange);
            // nested ----------
            function isDateRange (input) {
                if (isDate(input)) return true;

                if (__testRegExps([
                    /^\d{4}-\d{2}-\d{2}\s~\s[1-9]$/,                                      /* 1~9 */
                    /^\d{4}-\d{2}-\d{2}\s~\s(19|[2-9]\d)\d{0,2}$/,                        /* 20~99, 190~999, 1900~9999 */
                    /^\d{4}-\d{2}-\d{2}\s~\s(19|[2-9]\d)\d{2}-(0[1-9]?|1[0-2]?)?$/,       /* 1900-~9999-, 1900-0~9999-1, 1900-01~9999-12 */
                    /^\d{4}-\d{2}-\d{2}\s~\s(19|[2-9]\d)\d{2}-(0[1-9]|1[0-2])-$/], input) /* 1900-01-~9999-12- */
                ) {
                    var from = input.split(" ~ ")[0];
                    var to   = input.split(" ~ ")[1];

                    return (from.substr(0, to.length) <= to);
                } else
                if (/^\d{4}-\d{2}-\d{2}\s~\s(19|[2-9]\d)\d{2}-(0[1-9]|1[0-2])-(0[1-9]?|1\d?|2\d?|3[01]?)$/.test(input)) { /* 1900-01-0~9999123, 19000101~99991231 */
                    var endDate = (new Date(parseInt(input.split("-")[3], 10), parseInt(input.split("-")[4], 10), 0)).getDate();
                    switch (endDate) {
                        case 31: return true;
                        case 30: return /^\d{4}-\d{2}-\d{2}\s~\s\d{4}-\d{2}-(0[1-9]?|1[0-9]?|2[0-9]?|30?)$/.test(input); /* YYYY-01-0~YYYY-MM-3, YYYY-01-01~YYYY-MM-30 */
                        case 29: return /^\d{4}-\d{2}-\d{2}\s~\s\d{4}-\d{2}-(0[1-9]?|1[0-9]?|2[0-9]?)$/.test(input);     /* YYYY-01-0~YYYY-MM-2, YYYY-01-01~YYYY-MM-29 */
                        case 28: return /^\d{4}-\d{2}-\d{2}\s~\s\d{4}-\d{2}-(0[1-9]?|1[0-9]?|2[0-8]?)$/.test(input);     /* YYYY-01-0~YYYY-MM-2, YYYY-01-01~YYYY-MM-28 */
                        default: return false;
                    }
                } else {
                    return false;
                }
            }
        },

        format: function (input) {
            if (__testRegExps([
                    /^\d{4}-\d{2}-\d{0,2}\s~\s\d{4}-\d{0,2}-\d{0,2}$/,
                    /^\d{4}-\d{2}-\d{0,2}\s~\s\d{4}-\d{0,2}$/,
                    /^\d{4}-\d{2}-\d{0,2}\s~\s\d{0,4}$/, /* YYYY-MM-DD ~ Y, YYYY-MM-DD ~ YY, YYYY-MM-DD ~ YYY, YYYY-MM-DD ~ YYYY */
                    /^\d{4}-\d{2}-\d{0,2}$/, /* YYYY-MM-, YYYY-MM-D, YYYY-MM-DD */
                    /^\d{4}-\d{0,2}$/,       /* YYYY-, YYYY-M, YYYY-MM */
                    /^\d{0,4}$/], input)     /* Y, YY, YYY, YYYY */
            ) {
                return input;
            } else {
                return addDelimiters(removeDateRangeDelimiters(input));
            }
            // nested ----------
            function removeDateRangeDelimiters(input) {return input.replace(/-/g, "").replace(" ~ ", "");}
            function addDelimiters(input) {
                if      (15 <= input.length) return input.substr(0, 4) + "-" + input.substr(4, 2) + "-" + input.substr(6, 2) + " ~ " + input.substr(8, 4) + "-" + input.substr(12, 2) + "-" + input.substr(14);
                else if (13 <= input.length) return input.substr(0, 4) + "-" + input.substr(4, 2) + "-" + input.substr(6, 2) + " ~ " + input.substr(8, 4) + "-" + input.substr(12);
                else if ( 9 <= input.length) return input.substr(0, 4) + "-" + input.substr(4, 2) + "-" + input.substr(6, 2) + " ~ " + input.substr(8);
                else if ( 7 <= input.length) return input.substr(0, 4) + "-" + input.substr(4, 2) + "-" + input.substr(6);
                else if ( 5 <= input.length) return input.substr(0, 4) + "-" + input.substr(4);
                else                         return input;
            }
        }
    };
    // END   date range private method ----------

    // BEGIN date private method ----------
    var __DATE_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly()     && ifChanged(aKeydown) && isExpectedInRange(aKeydown)) addDelimiterIfNeeded(aKeydown);

            if ((isTrueThat(aKeydown).isBackspaceKeyOnly()) ||
                (isTrueThat(aKeydown).isHyphenKeyOnly()    && ifChanged(aKeydown) && !/^\d*-$/.test(currentValueFor(aKeydown))) ||
                (isTrueThat(aKeydown).isNumberKeyOnly()    && ifChanged(aKeydown) && isExpectedInRange(aKeydown))
            ) {
                allowInputAtLast(aKeydown);
            } else
            if (isTrueThat(aKeydown).isUpKeyOnly()         && ifChanged(aKeydown)) {
                if (isRightThat(currentValueFor(aKeydown), _isEqualTo(maxNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, minAttributeFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedDateFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, "YYYY-MM-DD", "↑");
                    });
                }
            } else
            if (isTrueThat(aKeydown).isDownKeyOnly()       && ifChanged(aKeydown)) {
                if (isRightThat(currentValueFor(aKeydown), _isEqualTo(minNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, maxAttributeFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedDateFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, "YYYY-MM-DD", "↓");
                    });
                }
            } else {
                doNothing(aKeydown, function () {
                    if (isTrueThat(aKeydown).isBackspaceKeyOnly() ||
                        isTrueThat(aKeydown).isHyphenKeyOnly()    ||
                        isTrueThat(aKeydown).isNumberKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.EXCEEDED, minAttributeFor(aKeydown) + " ~ " + maxAttributeFor(aKeydown));
                    } else
                    if (isTrueThat(aKeydown).isUpKeyOnly() ||
                        isTrueThat(aKeydown).isDownKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.NUMBER, "↑ ↓");
                    } else {
                        notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.NUMBER + " - ↑ ↓");
                    }
                });
            }

            // nested ----------
            function addDelimiterIfNeeded(aKeydown) {
                if (isNeeded(aKeydown)) __getTextBox(aKeydown).value += "-";
                // nested ----------
                function isNeeded(aKeydown) {
                    return __testRegExps([
                            /^(19|[2-9][0-9])[0-9]{2}$/, /* 1900~9999 */
                            /^(19|[2-9][0-9])[0-9]{2}-(0[1-9]|1[0-2])$/], currentValueFor(aKeydown)); /* 1900-01~9999-12 */
                }
            }
            function isExpectedInRange(aKeydown) {return isTrueThat(expectedDateFor(aKeydown)).isInRangeFor(aKeydown);}
            function expectedDateFor(aKeydown) {
                if (isTrueThat(aKeydown).isUpKeyOnly()) {
                    if (10 === currentValueFor(aKeydown).length) return addDays(currentValueFor(aKeydown), 1);
                    return currentValueFor(aKeydown);
                } else
                if (isTrueThat(aKeydown).isDownKeyOnly()) {
                    if (10 === currentValueFor(aKeydown).length) return addDays(currentValueFor(aKeydown), -1);
                    return currentValueFor(aKeydown);
                } else {
                    return __DATE_MASK.format(__DATE_MASK.apply(currentValueFor(aKeydown) + stringFromKey(aKeydown)));
                }
            }
            function ifChanged(aKeydown) {return isRightThat(currentValueFor(aKeydown), _isNotEqualTo(expectedDateFor(aKeydown)));}
        },

        handleChangeEvent: function (aChange) {
            var slicedValue;

            for (var length = slicedValueFor(aChange, __DATE_MASK.apply).length; length >= 1; length--) {
                slicedValue = slicedValueFor(aChange, __DATE_MASK.apply, length);
                if (isTrueThat(slicedValue).isInRangeFor(aChange)) {
                    __getTextBox(aChange).value = __DATE_MASK.format(slicedValue);
                    return;
                }
            }
            __getTextBox(aChange).value = "";
        },

        apply: function (input) {
            if (isDate(__DATE_MASK.format(input))) return __DATE_MASK.format(input);
            else                                   return extractValueFrom(input, isDate);
        },

        format: function (input) {
            if (__testRegExps([
                    /^\d{4}-\d{2}-\d{0,2}$/, /* YYYY-MM-, YYYY-MM-D, YYYY-MM-DD */
                    /^\d{4}-\d{0,2}$/,       /* YYYY-, YYYY-M, YYYY-MM */
                    /^\d{0,4}$/], input)     /* Y, YY, YYY, YYYY */
            ) {
                return input;
            } else {
                return addDelimiters(removeDateDelimiters(input));
            }
            // nested ----------
            function removeDateDelimiters(input) {return input.replace(/-/g, "");}
            function addDelimiters(input) {
                if      (7 <= input.length) return input.substr(0, 4) + "-" + input.substr(4, 2) + "-" + input.substr(6);
                else if (5 <= input.length) return input.substr(0, 4) + "-" + input.substr(4);
                else                        return input;
            }
        }
    };
    // END   date private method ----------

    // BEGIN ip address private method ----------
    var __IP_ADDRESS_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly()) addDelimiterIfNeeded(aKeydown);

            if ((isTrueThat(aKeydown).isBackspaceKeyOnly()) ||
                (isTrueThat(aKeydown).isDotKeyOnly()       && ifChanged(aKeydown)) ||
                (isTrueThat(aKeydown).isNumberKeyOnly()    && ifChanged(aKeydown))
            ) {
                allowInputAtLast(aKeydown);
            } else {
                doNothing(aKeydown, function () {
                    if (isTrueThat(aKeydown).isDotKeyOnly() ||
                        isTrueThat(aKeydown).isNumberKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.EXCEEDED, "0.0.0.0 ~ 255.255.255.255");
                    } else {
                        notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.NUMBER + " .");
                    }
                });
            }

            // nested ----------
            function addDelimiterIfNeeded(aKeydown) {
                if (isNeeded(aKeydown)) __getTextBox(aKeydown).value += ".";
                // nested ----------
                function isNeeded(aKeydown) {
                    // ... 250 ~ 255, 200 ~ 249, 100 ~ 199, 26 ~ 29, 30 ~ 99, 0
                    if (/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){0,2}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|2[6-9]|[3-9][0-9]|0)$/.test(currentValueFor(aKeydown))) {
                        return true;
                    } else
                    if (/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){0,2}(?:25)$/.test(currentValueFor(aKeydown))) { /* ... 25 */
                        if (isTrueThat(aKeydown).isBetween6KeyAnd9KeyOnly()) return true;
                    }
                    return false;
                }
            }
            function ifChanged(aKeydown) {
                return isRightThat(currentValueFor(aKeydown), _isNotEqualTo(expectedIpAddressFor(aKeydown)));
                // nested ----------
                function expectedIpAddressFor(aKeydown) {return __IP_ADDRESS_MASK.apply(
                    currentValueFor(aKeydown) +
                    (isTrueThat(aKeydown).isDotKeyOnly() ? "." : aKeydown.key)
                );}
            }
        },

        apply: function (input) {
            if (isIpAddress(input)) return input;
            else                    return extractValueFrom(input, isIpAddress);

            // nested ----------
            function isIpAddress(input) {
                // [0 ~ 255]+[.] -> (3개이하) // [0 ~ 255] -> (1개이하)
                return /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){0,3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])?$/.test(input);
            }
        }
    };
    // END   mac address private method ----------

    // BEGIN phone number address private method ----------
    var __MAC_ADDRESS_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly()                  ||
                isTrueThat(aKeydown).isBetweenAKeyAndFKeyOnly()         ||
                isTrueThat(aKeydown).isBetweenAKeyAndFKeyWithShiftKey()
            ) {
                addDelimiterIfNeeded(aKeydown);
            }

            if ((isTrueThat(aKeydown).isBackspaceKeyOnly()                                     ) ||
                (isTrueThat(aKeydown).isNumberKeyOnly()                  && ifChanged(aKeydown)) ||
                (isTrueThat(aKeydown).isBetweenAKeyAndFKeyOnly()         && ifChanged(aKeydown)) ||
                (isTrueThat(aKeydown).isBetweenAKeyAndFKeyWithShiftKey() && ifChanged(aKeydown)) ||
                (isTrueThat(aKeydown).isHyphenKeyOnly()                  && ifChanged(aKeydown) && isRightThat(delimiterForMacAddress(), _isEqualTo("-"))) ||
                (isTrueThat(aKeydown).isColonKeyOnly()                   && ifChanged(aKeydown) && isRightThat(delimiterForMacAddress(), _isEqualTo(":")))
            ) {
                allowInputAtLast(aKeydown);
            } else {
                doNothing(aKeydown, function () {
                    if (
                        isTrueThat(aKeydown).isNumberKeyOnly() ||
                        isTrueThat(aKeydown).isBetweenAKeyAndFKeyOnly() ||
                        isTrueThat(aKeydown).isBetweenAKeyAndFKeyWithShiftKey() ||
                        isTrueThat(aKeydown).isHyphenKeyOnly() ||
                        isTrueThat(aKeydown).isColonKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.EXCEEDED, "00:00:00:00:00:00 ~ FF:FF:FF:FF:FF:FF".replace(/:/g, delimiterForMacAddress()));
                    } else {
                        notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.NUMBER + " A B C D E F " + delimiterForMacAddress());
                    }
                });
            }

            // nested ----------
            function addDelimiterIfNeeded(aKeydown) {
                if (isNeeded(aKeydown)) __getTextBox(aKeydown).value += delimiterForMacAddress();
                // nested ----------
                function isNeeded(aKeydown) {return /^([0-9a-fA-F][0-9a-fA-F][:\-]){0,4}[0-9a-fA-F]{2}$/.test(currentValueFor(aKeydown));}
            }
            function delimiterForMacAddress() {return ["-", ":"][__macAddressDelimiter];}
            function ifChanged(aKeydown) {
                return isRightThat(currentValueFor(aKeydown).toUpperCase(), _isNotEqualTo(expectedMacAddressFor(aKeydown)));
                // nested ----------
                function expectedMacAddressFor(aKeydown) {return __MAC_ADDRESS_MASK.apply(
                    currentValueFor(aKeydown).toUpperCase() + stringFromKey(aKeydown)
                );}
            }
        },

        apply: function (input) {
            if (isMacAddress(input)) return input.toUpperCase();
            else                     return extractValueFrom(input, isMacAddress).toUpperCase();

            // nested ----------
            function isMacAddress(input) {return /^([0-9a-fA-F][0-9a-fA-F][:\-]){0,5}[0-9a-fA-F]{0,2}$/.test(input);}
        }
    };
    // END   mac address private method ----------

    // BEGIN phone number address private method ----------
    var __PHONE_NUMBER_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly()) {
                addDelimiterIfNeeded(aKeydown);
                moveDelimiterBackwardIfNeeded(aKeydown);
            } else
            if (isTrueThat(aKeydown).isBackspaceKeyOnly()) {
                moveDelimiterForwardIfNeeded(aKeydown);
                removeDelimiterIfNeeded(aKeydown);
            }

            if (( isTrueThat(aKeydown).isBackspaceKeyOnly()                          ) ||
                ((isTrueThat(aKeydown).isNumberKeyOnly()   ) && (ifChanged(aKeydown)))
            ) {
                allowInputAtLast(aKeydown);
            } else {
                doNothing(aKeydown, function () {
                    if (isTrueThat(aKeydown).isNumberKeyOnly()) {
                        notify(_MASK.MESSAGES.SUPPORTED, "02-###-#### / 02-####-#### / ###-###-#### / ###-####-####");
                    } else {
                        notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.NUMBER);
                    }
                });
            }

            // nested ----------
            function addDelimiterIfNeeded(aKeydown) {
                if (isNeeded(aKeydown)) __getTextBox(aKeydown).value += "-";
                // nested ----------
                function isNeeded(aKeydown) {
                    return (__testRegExps([/^\d{2,3}-\d{3}$/, /^(?:02|(?:\d{3}))$/], currentValueFor(aKeydown)));
                }
            }
            function moveDelimiterBackwardIfNeeded(aKeydown) { /* 2/3자리-3자리-4자리 -> 2/3자리-4자리-4자리 */
                if (isNotNeeded(aKeydown)) return;
                __getTextBox(aKeydown).value = firstPartOfPhoneNumber(aKeydown) + "-" + otherPartsOfPhoneNumber(aKeydown, 4);
                // nested ----------
                function isNotNeeded(aKeydown) {return !(/^\d{2,3}-\d{3}-\d{4}$/.test(currentValueFor(aKeydown)));}
            }
            function moveDelimiterForwardIfNeeded(aKeydown) { /* 2/3자리-4자리-4자리 -> 2/3자리-3자리-4자리 */
                if (isNotNeeded(aKeydown)) return;
                __getTextBox(aKeydown).value = firstPartOfPhoneNumber(aKeydown) + "-" + otherPartsOfPhoneNumber(aKeydown, 3);
                // nested ----------
                function isNotNeeded(aKeydown) {return !(/^\d{2,3}-\d{4}-\d{4}$/.test(currentValueFor(aKeydown)));}
            }
            function removeDelimiterIfNeeded(aKeydown) { /* 2/3자리-3자리-1자리 -> 2/3자리-3자리 */
                doIf3Parts(aKeydown);
                doIf2Parts(aKeydown);
                // nested ----------
                function doIf3Parts() {
                    if (isNeeded(aKeydown)) __getTextBox(aKeydown).value = firstPartOfPhoneNumber(aKeydown) + "-" + otherPartsOfPhoneNumber(aKeydown);
                    // nested ----------
                    function isNeeded(aKeydown) {return /^\d{2,3}-\d{3}-\d$/.test(currentValueFor(aKeydown));}
                }
                function doIf2Parts(aKeydown) { /* 2/3자리-1자리 -> 2/3자리 */
                    if (isNeeded(aKeydown)) __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace(/-/g, "");
                    // nested ----------
                    function isNeeded(aKeydown) {return /^\d{2,3}-\d$/.test(currentValueFor(aKeydown));}
                }
            }
            function firstPartOfPhoneNumber(aKeydown) {return currentValueFor(aKeydown).split("-")[0];}
            function otherPartsOfPhoneNumber(aKeydown, indexOfDelimiter) {
                if (isRightThat(indexOfDelimiter, _isNull())) {
                    return currentValueFor(aKeydown).split("-")[1] + currentValueFor(aKeydown).split("-")[2];
                } else {
                    var otherParts = currentValueFor(aKeydown).split("-")[1] + currentValueFor(aKeydown).split("-")[2];
                    return otherParts.substr(0, indexOfDelimiter) + "-" + otherParts.substr(indexOfDelimiter);
                }
            }
            function ifChanged(aKeydown) {
                return isRightThat(currentValueFor(aKeydown), _isNotEqualTo(expectedPhoneNumberFor(aKeydown)));
                // nested ----------
                function expectedPhoneNumberFor(aKeydown) {
                    return __PHONE_NUMBER_MASK.apply(currentValueFor(aKeydown) + aKeydown.key);
                }
            }
        },

        apply: function (input) {
            if (isPhoneNumber(input)) return input;
            else                      return extractValueFrom(input, isPhoneNumber);

            // nested ----------
            function isPhoneNumber(input) {return __testRegExps([
                /^\d{2,3}-\d{3,4}-\d{0,4}$/, /* 숫자2/3자리 - 숫자3/4자리 - 숫자0/4자리 */
                /^\d{2,3}-\d{0,4}$/,         /* 숫자2/3자리 - 숫자0/4자리 */
                /^\d{1,3}$/], input);        /* 숫자1/3자리 */
            }
        }
    };
    // END   phone number address private method ----------

    // BEGIN defined private method ----------
    var __DEFINED_MASK = {
        handleKeyupEvent: function (aKeyup) {
            if (isRightThat(currentValueFor(aKeyup), _isNotEmpty()) &&
                isRightThat(currentValueFor(aKeyup), _isNotEqualTo(expectedDefinedFor(aKeyup)))
            ) {
                if (currentValueFor(aKeyup) !== expectedDefinedFor(aKeyup)) {
                    notify(_MASK.MESSAGES.ALLOWED, charsAttributeFor(aKeyup));
                }
                __getTextBox(aKeyup).value = expectedDefinedFor(aKeyup);
            }

            // nested ----------
            function expectedDefinedFor(aKeyup) {return __DEFINED_MASK.apply(currentValueFor(aKeyup), charsAttributeFor(aKeyup), caseAttributeFor(aKeyup));}
        },

        handleChangeEvent: function (aChange) {__DEFINED_MASK.handleKeyupEvent(aChange);},

        apply: function (input, definedChars, definedCase) {
            var output = "";
            var newInput = ("upper" === definedCase ? input.toUpperCase() : ("lower" === definedCase ? input.toLowerCase() : input));
            var test;

            if (null == definedChars || 0 === definedChars.toString().length) return output;
            for (var index = 0; index < newInput.length; index++) {
                test = newInput.charAt(index);
                if (isOkThat(test).isOneOf(definedChars)) output += test;
            }
            return output;

            // nested ----------
            function isOkThat (char) {return {
                isOneOf: function (definedChars) {return (0 <= definedChars.indexOf(char));}
            };}
        }
    };
    // END   defined private method ----------

    // BEGIN user id private method ----------
    var __USER_ID_MASK = {
        handleKeyupEvent: function (aKeyup) {
            if (isRightThat(currentValueFor(aKeyup), _isNotEmpty()) &&
                isRightThat(currentValueFor(aKeyup), _isNotEqualTo(expectedUserIdFor(aKeyup)))
            ) {
                if (currentValueFor(aKeyup) !== expectedUserIdFor(aKeyup)) {
                    notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.ALPHABET + " " + _MASK.MESSAGES.NUMBER + " " + _MASK.MESSAGES.DOT + " " + _MASK.MESSAGES.UNDER_BAR + " " + _MASK.MESSAGES.HYPHEN);
                }
                __getTextBox(aKeyup).value = expectedUserIdFor(aKeyup);
            }

            // nested ----------
            function expectedUserIdFor(aKeyup) {return __USER_ID_MASK.apply(currentValueFor(aKeyup));}
        },

        handleChangeEvent: function (aChange) {__USER_ID_MASK.handleKeyupEvent(aChange);},

        apply: function (input) {
            return extractAlphabetAndNumberDotFrom(input);

            // nested ----------
            function extractAlphabetAndNumberDotFrom(input) {return input.replace(/[^0-9a-zA-Z._-]/g, "");}
        }
    };
    // END   user id private method ----------

    // BEGIN email private method ----------
    var __EMAIL_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isAlphabetUpperCaseKeyOnly() && aKeydown.getModifierState("CapsLock")) {
                notify(_MASK.MESSAGES.CAPS_LOCK);
            }
        },

        handleKeyupEvent: function (aKeyup) {
            if (isRightThat(currentValueFor(aKeyup), _isNotEmpty()) &&
                isRightThat(currentValueFor(aKeyup), _isNotEqualTo(expectedEmailFor(aKeyup)))
            ) {
                if (currentValueFor(aKeyup) !== expectedEmailFor(aKeyup)) {
                    notify(_MASK.MESSAGES.NOT_ALLOWED, _MASK.MESSAGES.KOREAN + " " + _MASK.MESSAGES.ALPHABET_UPPER_CASE);
                }
                __getTextBox(aKeyup).value = expectedEmailFor(aKeyup);
            }

            // nested ----------
            function expectedEmailFor(aKeyup) {return __EMAIL_MASK.apply(currentValueFor(aKeyup));}
        },

        handleChangeEvent: function (aChange) {__EMAIL_MASK.handleKeyupEvent(aChange);},

        apply: function (input) {
            return deduplicateDelimiterOn(input).toLowerCase();

            // nested ----------
            function deduplicateDelimiterOn(input) {
                var emailParts = removeKoreanFrom(input).split("@");
                if (isRightThat(emailParts.length, _isGreaterThan(1))) {
                    emailParts[0] += "@";
                    return emailParts.join("");
                } else {
                    return removeKoreanFrom(input);
                }
                // nested ----------
                function removeKoreanFrom(input) {return input.toString().replace(/[\u3131-\u318E\uAC00-\uD7A3]/g, "");}
                // function removeKoreanFrom(input) {return input.toString().replace(/[ㄱ-ㅎㅏ-ㅣ가-힣]/g, "");}
            }
        }
    };
    // END  email private method ----------

    // BEGIN integer private method ----------
    var __INTEGER_MASK = {
        RANGE: {MAX: 999999999999999, MIN: -999999999999999},

        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly() && isExpectedInRange(aKeydown)) removeFirstZeroIfNeeded(aKeydown);

            if ((isTrueThat(aKeydown).isBackspaceKeyOnly()                                                      ) ||
                (isTrueThat(aKeydown).isNumberKeyOnly()    && ifChanged(aKeydown) && isExpectedInRange(aKeydown))
            ) {
                allowInputAtLast(aKeydown);
            } else
            if (isTrueThat(aKeydown).isHyphenKeyOnly() && isPossibleToAddMinusSign(aKeydown)) {
                __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace("+", "");
                allowInputAtFirst(aKeydown);
            } else
            if (isTrueThat(aKeydown).isPlusKeyOnly() && isPossibleToAddPlusSign(aKeydown)) {
                __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace("-", "");
                allowInputAtFirst(aKeydown);
            } else
            if (isTrueThat(aKeydown).isUpKeyOnly() && isRightThat(currentValueFor(aKeydown), _isNotAllOf(["", "-", "+"]))) {
                if (isRightThat(currentValueFor(aKeydown), _isEqualTo(maxNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, minMultipleOfStepFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedIntegerFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.NUMBER, "↑");
                    });
                }
            } else
            if (isTrueThat(aKeydown).isDownKeyOnly() && isRightThat(currentValueFor(aKeydown), _isNotAllOf(["", "-", "+"]))) {
                if (isRightThat(currentValueFor(aKeydown), _isEqualTo(minNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, maxMultipleOfStepFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedIntegerFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.NUMBER, "↓");
                    });
                }
            } else {
                doNothing(aKeydown, function () {
                    if (isTrueThat(aKeydown).isNumberKeyOnly() ||
                        isTrueThat(aKeydown).isHyphenKeyOnly() ||
                        isTrueThat(aKeydown).isPlusKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.EXCEEDED, minMultipleOfStepFor(aKeydown) + " ~ " + maxMultipleOfStepFor(aKeydown));
                    } else
                    if (isTrueThat(aKeydown).isUpKeyOnly() ||
                        isTrueThat(aKeydown).isDownKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.NUMBER, "↑ ↓");
                    } else {
                        var sign = "";
                        if (0 > minMultipleOfStepFor(aKeydown)) {
                            sign += " -";
                            if (0 < maxMultipleOfStepFor(aKeydown)) {
                                sign += " +";
                            }
                        }

                        notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.NUMBER + sign + " ↑ ↓");
                    }
                });
            }

            // nested ----------
            function ifChanged(aKeydown) {
                return isRightThat(currentValueFor(aKeydown), _isNotEqualTo(expectedIntegerFor(aKeydown).toString()));
            }
            function expectedIntegerFor(aKeydown) {
                if (isTrueThat(aKeydown).isUpKeyOnly()) {
                    return Number(currentValueFor(aKeydown)) + stepNumberFor(aKeydown);
                } else
                if (isTrueThat(aKeydown).isDownKeyOnly()) {
                    return Number(currentValueFor(aKeydown)) - stepNumberFor(aKeydown);
                } else {
                    return Number(__INTEGER_MASK.apply(currentValueFor(aKeydown) + aKeydown.key));
                }
            }
            function isExpectedInRange(aKeydown) {
                if (0 <= expectedIntegerFor(aKeydown)) {
                    return isRightThat(maxNumberFor(aKeydown), _isNotLessThan(expectedIntegerFor(aKeydown)));
                } else {
                    return isRightThat(minNumberFor(aKeydown), _isNotGreaterThan(expectedIntegerFor(aKeydown)));
                }
            }
            function isPossibleToAddMinusSign(aKeydown) {
                return (
                    isRightThat(minNumberFor(aKeydown), _isLessThan(0)) &&
                    (
                        isRightThat(currentValueFor(aKeydown), _isAnyOf(["", "+"])) ||
                        /^[+]?[1-9][0-9]*$/.test(currentValueFor(aKeydown))
                    )
                );
            }
            function isPossibleToAddPlusSign(aKeydown) {
                return (
                    isRightThat(maxNumberFor(aKeydown), _isGreaterThan(0)) &&
                    (
                        isRightThat(currentValueFor(aKeydown), _isEqualTo("-")) ||
                        /^-[1-9][0-9]*$/.test(currentValueFor(aKeydown))
                    )
                );
            }
        },

        handleChangeEvent: function (aChange) {
            var slicedValue;

            for (var length = slicedValueFor(aChange, __INTEGER_MASK.apply).length; length >= 1; length--) { /* 뒤에서부터 1자리씩 잘라 정수이면 항목에 표시한다. */
                slicedValue = slicedValueFor(aChange, __INTEGER_MASK.apply, length);
                if (isTrueThat(slicedValue).isNumberString() &&
                    isTrueThat( Number(slicedValue)).isInRangeFor(aChange) &&
                    isRightThat(Number(slicedValue), _isAMultipleOf(stepNumberFor(aChange)))
                ) {
                    __getTextBox(aChange).value = slicedValue;
                    return;
                }
            }
            __getTextBox(aChange).value = "";
        },

        apply: function (input) {
            if (isTrueThat(input).isInteger()) return input;
            else                               return extractIntegerFrom(input);

            // nested ----------
            function extractIntegerFrom(input) { /* 앞에서 부터 1자리씩 잘라 정수인 경우만 붙여준다. */
                var output = "";
                var test;
                for (var index = 0; index < input.length; index++) {
                    test = output + input.charAt(index);
                    if      (isTrueThat(test).isInteger()) output = test;
                    else if (isTrueThat(test).isNumber()) output = input.charAt(index);
                }
                return output;
            }
        }
    };
    // END   integer private method ----------

    // BEGIN currency private method ----------
    var __CURRENCY_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly() && isExpectedInRange(aKeydown)) removeFirstZeroIfNeeded(aKeydown);

            if ((isTrueThat(aKeydown).isBackspaceKeyOnly()                                                      ) ||
                (isTrueThat(aKeydown).isNumberKeyOnly()    && ifChanged(aKeydown) && isExpectedInRange(aKeydown))
            ) {
                formatIfNeeded(aKeydown);
                allowInputAtLast(aKeydown);
            } else
            if (isTrueThat(aKeydown).isHyphenKeyOnly() && isPossibleToAddMinusSign(aKeydown)) {
                __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace("+", "");
                allowInputAtFirst(aKeydown);
            } else
            if (isTrueThat(aKeydown).isPlusKeyOnly() && isPossibleToAddPlusSign(aKeydown)) {
                __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace("-", "");
                allowInputAtFirst(aKeydown);
            } else
            if (isTrueThat(aKeydown).isUpKeyOnly() && isRightThat(currentValueFor(aKeydown), _isNotAllOf(["", "-", "+"]))) {
                if (isRightThat(currentValueWithoutDelimitersFor(aKeydown), _isEqualTo(maxNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, minMultipleOfStepFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedCurrencyFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.KRW, "↑");
                    });
                }
            } else
            if (isTrueThat(aKeydown).isDownKeyOnly() && isRightThat(currentValueFor(aKeydown), _isNotAllOf(["", "-", "+"]))) {
                if (isRightThat(currentValueWithoutDelimitersFor(aKeydown), _isEqualTo(minNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, maxMultipleOfStepFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedCurrencyFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.KRW, "↓");
                    });
                }
            } else {
                doNothing(aKeydown, function () {
                    if (isTrueThat(aKeydown).isNumberKeyOnly() ||
                        isTrueThat(aKeydown).isHyphenKeyOnly() ||
                        isTrueThat(aKeydown).isPlusKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.EXCEEDED, minMultipleOfStepFor(aKeydown) + " ~ " + maxMultipleOfStepFor(aKeydown));
                    } else
                    if (isTrueThat(aKeydown).isUpKeyOnly() ||
                        isTrueThat(aKeydown).isDownKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.KRW, "↑ ↓");
                    } else {
                        var sign = "";
                        if (0 > minMultipleOfStepFor(aKeydown)) {
                            sign += " -";
                            if (0 < maxMultipleOfStepFor(aKeydown)) {
                                sign += " +";
                            }
                        }

                        notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.NUMBER + sign + " ↑ ↓");
                    }
                });
            }

            // nested ----------
            function ifChanged(aKeydown) {
                return isRightThat(currentValueFor(aKeydown), _isNotEqualTo(expectedCurrencyFor(aKeydown)));
            }
            function expectedCurrencyFor(aKeydown) {return __CURRENCY_MASK.format(expectedNumberFor(aKeydown).toString())}
            function expectedNumberFor(aKeydown) {
                if (isTrueThat(aKeydown).isUpKeyOnly()) {
                    return Number(currentValueWithoutDelimitersFor(aKeydown)) + stepNumberFor(aKeydown);
                } else
                if (isTrueThat(aKeydown).isDownKeyOnly()) {
                    return Number(currentValueWithoutDelimitersFor(aKeydown)) - stepNumberFor(aKeydown);
                } else {
                    return Number(__CURRENCY_MASK.apply(currentValueFor(aKeydown) + aKeydown.key));
                }
            }
            function currentValueWithoutDelimitersFor(aKeydown) {return __CURRENCY_MASK.removeDelimiters(currentValueFor(aKeydown));}
            function isExpectedInRange(aKeydown) {
                if (0 <= expectedNumberFor(aKeydown)) {
                    return isRightThat(maxNumberFor(aKeydown), _isNotLessThan(expectedNumberFor(aKeydown)));
                } else {
                    return isRightThat(minNumberFor(aKeydown), _isNotGreaterThan(expectedNumberFor(aKeydown)));
                }
            }
            function formatIfNeeded(aKeydown) {
                var expectedValue;
                if (isTrueThat(aKeydown).isBackspaceKeyOnly()) {
                    expectedValue = __CURRENCY_MASK.format(currentValueFor(aKeydown).substr(0, currentValueFor(aKeydown).length - 1));
                    __getTextBox(aKeydown).value = expectedValue + currentValueFor(aKeydown).charAt(currentValueFor(aKeydown).length - 1);
                } else {
                    expectedValue = expectedCurrencyFor(aKeydown);
                    __getTextBox(aKeydown).value = expectedValue.substr(0, expectedValue.length - 1);
                }
            }
            function isPossibleToAddMinusSign(aKeydown) {
                return (
                    isRightThat(minNumberFor(aKeydown), _isLessThan(0)) &&
                    (
                        isRightThat(currentValueFor(aKeydown), _isEqualTo("")) ||
                        /^[+]?[1-9][0-9]*$/.test(currentValueWithoutDelimitersFor(aKeydown))
                    )
                );
            }
            function isPossibleToAddPlusSign(aKeydown) {
                return (
                    isRightThat(maxNumberFor(aKeydown), _isGreaterThan(0)) &&
                    (
                        isRightThat(currentValueFor(aKeydown), _isEqualTo("-")) ||
                        /^-[1-9][0-9]*$/.test(currentValueWithoutDelimitersFor(aKeydown))
                    )
                );
            }
        },

        handleChangeEvent: function (aChange) {
            var slicedValue;

            for (var length = slicedValueFor(aChange, __CURRENCY_MASK.apply).length; length >= 1; length--) {
                slicedValue = slicedValueFor(aChange, __CURRENCY_MASK.apply, length);
                if (isTrueThat(slicedValue).isNumberString() &&
                    isTrueThat( Number(slicedValue)).isInRangeFor(aChange) &&
                    isRightThat(Number(slicedValue), _isAMultipleOf(stepNumberFor(aChange)))
                ) {
                    __getTextBox(aChange).value = __CURRENCY_MASK.format(slicedValue);
                    return;
                }
            }
            __getTextBox(aChange).value = "";
        },

        apply: function (input) {return __INTEGER_MASK.apply(__CURRENCY_MASK.removeDelimiters(input));},

        removeDelimiters: function (input) {return input.replace(/,/g, "");},

        format: function (input) {
            return addDelimiters(__CURRENCY_MASK.removeDelimiters(input));
            // nested ----------
            function addDelimiters(input) {return input.replace(/\B(?=(\d{3})+(?!\d))/g, ",");}
        }
    };
    // END   currency private method ----------

    // BEGIN decimal private method ----------
    var __DECIMAL_MASK = {
        handleKeydownEvent: function (aKeydown) {
            if (isTrueThat(aKeydown).isNumberKeyOnly()) {
                removeFirstZeroIfNeeded(aKeydown);
                removeLastZeroIfNeeded(aKeydown);
            }

            if ((isTrueThat(aKeydown).isBackspaceKeyOnly()                                                          ) ||
                (isTrueThat(aKeydown).isNumberKeyOnly()    && ifChanged(aKeydown) && isExpectedInRange(aKeydown))
            ) {
                allowInputAtLast(aKeydown);
            } else
            if (isTrueThat(aKeydown).isDotKeyOnly() && isPossibleToAddDot(aKeydown)) {
                allowInputAtLast(aKeydown);
            } else
            if (isTrueThat(aKeydown).isHyphenKeyOnly() && isPossibleToAddMinusSign(aKeydown)) {
                __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace("+", "");
                allowInputAtFirst(aKeydown);
            } else
            if ((isTrueThat(aKeydown).isPlusKeyOnly()) && (isPossibleToAddPlusSign(aKeydown))) {
                __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace("-", "");
                allowInputAtFirst(aKeydown);
            } else
            if (isTrueThat(aKeydown).isUpKeyOnly() && isRightThat(currentValueFor(aKeydown), _isNotAllOf(["", "-", "+"]))) {
                if (isRightThat(currentValueFor(aKeydown), _isEqualTo(maxNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, minMultipleOfStepFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedDecimalFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.NUMBER, "↑");
                    });
                }
            } else
            if ((isTrueThat(aKeydown).isDownKeyOnly()) && isRightThat(currentValueFor(aKeydown), _isNotAllOf(["", "-", "+"]))) {
                if (isRightThat(currentValueFor(aKeydown), _isEqualTo(minNumberFor(aKeydown).toString())) || !isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, maxMultipleOfStepFor(aKeydown));
                } else
                if (isExpectedInRange(aKeydown)) {
                    changeValue(aKeydown, expectedDecimalFor(aKeydown));
                } else {
                    doNothing(aKeydown, function () {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.NUMBER, "↓");
                    });
                }
            } else {
                doNothing(aKeydown, function () {
                    if (isTrueThat(aKeydown).isNumberKeyOnly() ||
                        isTrueThat(aKeydown).isDotKeyOnly()    ||
                        isTrueThat(aKeydown).isHyphenKeyOnly() ||
                        isTrueThat(aKeydown).isPlusKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.EXCEEDED, minMultipleOfStepFor(aKeydown) + " ~ " + maxMultipleOfStepFor(aKeydown));
                    } else
                    if (isTrueThat(aKeydown).isUpKeyOnly() ||
                        isTrueThat(aKeydown).isDownKeyOnly()
                    ) {
                        notify(_MASK.MESSAGES.NOT_ENOUGH, _MASK.MESSAGES.NUMBER, "↑ ↓");
                    } else {
                        var sign = "";
                        if (0 > minMultipleOfStepFor(aKeydown)) {
                            sign += " -";
                            if (0 < maxMultipleOfStepFor(aKeydown)) {
                                sign += " +";
                            }
                        }

                        notify(_MASK.MESSAGES.ALLOWED, _MASK.MESSAGES.NUMBER + sign + " ↑ ↓");
                    }
                });
            }

            // nested ----------
            function removeLastZeroIfNeeded(aKeydown) {
                if (/^[+-]?\d*[.][1-9]*[0]+$/.test(currentValueFor(aKeydown)) && isTrueThat(aKeydown).isZeroKeyOnly() && currentValueFor(aKeydown).split(".")[1].length >= fractionDigitsNumberFor(aKeydown)) {
                    __getTextBox(aKeydown).value = currentValueFor(aKeydown).substr(0, currentValueFor(aKeydown).length - 1);
                }
                // if (/^[+-]?\d*[.]00$/.test(currentValueFor(aKeydown)) && isTrueThat(aKeydown).isZeroKeyOnly()) {
                //     __getTextBox(aKeydown).value = currentValueFor(aKeydown).substr(0, currentValueFor(aKeydown).length - 1);
                // }
            }
            function ifChanged(aKeydown) {
                return isRightThat(currentValueFor(aKeydown), _isNotEqualTo(expectedDecimalFor(aKeydown).toString()));
            }
            function expectedDecimalFor(aKeydown) {
                var multiple = Math.pow(10, fractionDigitsNumberFor(aKeydown));
                if (isTrueThat(aKeydown).isUpKeyOnly()) {
                    return (Math.round(Number(currentValueFor(aKeydown)) * multiple) + Math.round(stepNumberFor(aKeydown) * multiple)) / multiple;
                } else
                if (isTrueThat(aKeydown).isDownKeyOnly()) {
                    return (Math.round(Number(currentValueFor(aKeydown)) * multiple) - Math.round(stepNumberFor(aKeydown) * multiple)) / multiple;
                } else {
                    return __DECIMAL_MASK.apply(currentValueFor(aKeydown) + aKeydown.key);
                    // return Number(__DECIMAL_MASK.apply(currentValueFor(aKeydown) + aKeydown.key));
                }
            }
            function isExpectedInRange(aKeydown) {
                return (
                    isRightThat(expectedDecimalFor(aKeydown)       , _isBetween(minNumberFor(aKeydown)).and(maxNumberFor(aKeydown))) &&
                    isRightThat(expectedFractionDigitsFor(aKeydown), _isNotGreaterThan(fractionDigitsNumberFor(aKeydown)))
                );
                // nested ----------
                function expectedFractionDigitsFor(aKeydown) {
                    var parts = expectedDecimalFor(aKeydown).toString().split(".");
                    return (isRightThat(parts.length, _isGreaterThan(1)) ? parts[1].length : 0);
                }
            }
            function isPossibleToAddDot(aKeydown) {
                return __testRegExps([/^-?0$/, /^-?[1-9][0-9]*$/], currentValueFor(aKeydown));
            }
            function isPossibleToAddMinusSign(aKeydown) {
                return (
                    (isRightThat(minNumberFor(aKeydown), _isLessThan(0))) &&
                    (
                        isRightThat(currentValueFor(aKeydown), _isEqualTo("")) ||
                        __testRegExps([/^[+]?0(.[0-9]*)?$/, /^[+]?[1-9][0-9]*(.?[0-9]*)?$/], currentValueFor(aKeydown))
                    )
                );
            }
            function isPossibleToAddPlusSign(aKeydown) {
                return (
                    (isRightThat(maxNumberFor(aKeydown), _isGreaterThan(0))) &&
                    (
                        isRightThat(currentValueFor(aKeydown), _isEqualTo("-")) ||
                        __testRegExps([/^-0(.[0-9]*)?$/, /^-[1-9][0-9]*(.?[0-9]*)?$/], currentValueFor(aKeydown))
                    )
                );
            }
        },

        handleChangeEvent: function (aChange) {
            var slicedValue;

            for (var length = slicedValueFor(aChange, __DECIMAL_MASK.apply).length; length >= 1; length--) { /* 뒤에서부터 1자리씩 잘라 정수이면 항목에 표시한다. */
                slicedValue = slicedValueFor(aChange, __DECIMAL_MASK.apply, length);
                if (isDecimalString(slicedValue) &&
                    isTrueThat( Number(slicedValue)).isInRangeFor(aChange) &&
                    isRightThat(Number(slicedValue), _isAMultipleOf(stepNumberFor(aChange)))
                ) {
                    __getTextBox(aChange).value = slicedValue;
                    return;
                }
            }
            __getTextBox(aChange).value = "";

            // nested ----------
            function isDecimalString(input) {
                return __testRegExps([/^0(.[0-9]*[1-9])?$/, /^-0.[0-9]*[1-9]$/, /^-?[1-9][0-9]*(.[0-9]*[1-9])?$/], input);
            }
        },

        apply: function (input) {
            if (isDecimal(input)) return input;
            else                  return extractValueFrom(input, isDecimal);

            // nested ----------
            function isDecimal(input) {
                return __testRegExps([/^0$/, /^-?0.[0-9]*$/, /^-?[1-9][0-9]*.?[0-9]*$/, /^-$/], input);
            }
        }
    };
    // END   decimal private method ----------

    // BEGIN common private method ----------
    var __handleContextmenuEvent = function (aContextmenu) {
        var validTypes = [__TYPES.IP, __TYPES.MAC_ADDRESS, __TYPES.PHONE_NUMBER, __TYPES.INTEGER, __TYPES.CURRENCY, __TYPES.DECIMAL, __TYPES.DATE, __TYPES.DATE_RANGE];
        if (isRightThat(maskTypeFor(aContextmenu), _isAnyOf(validTypes))) doNothing(aContextmenu);
    };
    var __handleSelectEvent = function (aSelect) {
        if (__IS_NO_SELECT) {
            __IS_NO_SELECT = false;
        } else {
            var validTypes = [__TYPES.IP, __TYPES.MAC_ADDRESS, __TYPES.PHONE_NUMBER, __TYPES.INTEGER, __TYPES.CURRENCY, __TYPES.DECIMAL, __TYPES.DATE, __TYPES.DATE_RANGE];
            if (isRightThat(maskTypeFor(aSelect), _isAnyOf(validTypes))) __getTextBox(aSelect).select();
        }
    };
    var __handleKeydownEvent = function (aKeydown) {
        handleMaskKeydownEvent(aKeydown, findKeyDownHandlerFor(aKeydown));

        // nested ----------
        function handleMaskKeydownEvent(aKeydown, aKeydownEventHandler) {
            if (isTrueThat(aKeydown).isCKeyWithCtrlKey() || isTrueThat(aKeydown).isXKeyWithCtrlKey() ||
                isTrueThat(aKeydown).isVKeyWithCtrlKey() || isTrueThat(aKeydown).isAKeyWithCtrlKey() ||
                isTrueThat(aKeydown).isAllowedKeys()
            ) {
                // 위 KEY 입력을 허용한다.
            } else {
                if (isRightThat(aKeydownEventHandler, _isNotNull())) aKeydownEventHandler(aKeydown);
            }
        }
        function findKeyDownHandlerFor(aKeydown) {
            switch (maskTypeFor(aKeydown)) {
                case __TYPES.IP:           return   __IP_ADDRESS_MASK.handleKeydownEvent;
                case __TYPES.MAC_ADDRESS:  return  __MAC_ADDRESS_MASK.handleKeydownEvent;
                case __TYPES.PHONE_NUMBER: return __PHONE_NUMBER_MASK.handleKeydownEvent;
                case __TYPES.INTEGER:      return      __INTEGER_MASK.handleKeydownEvent;
                case __TYPES.CURRENCY:     return     __CURRENCY_MASK.handleKeydownEvent;
                case __TYPES.DECIMAL:      return      __DECIMAL_MASK.handleKeydownEvent;
                case __TYPES.DATE:         return         __DATE_MASK.handleKeydownEvent;
                case __TYPES.DATE_RANGE:   return   __DATE_RANGE_MASK.handleKeydownEvent;
                case __TYPES.EMAIL:        return        __EMAIL_MASK.handleKeydownEvent;
                default:                   return null;
            }
        }
    };
    var __handleKeyupEvent = function (aKeyup) {
        if (isRightThat(maskTypeFor(aKeyup), _isEqualTo(__TYPES.EMAIL  )))   __EMAIL_MASK.handleKeyupEvent(aKeyup);
        else
        if (isRightThat(maskTypeFor(aKeyup), _isEqualTo(__TYPES.USER_ID))) __USER_ID_MASK.handleKeyupEvent(aKeyup);
        else
        if (isRightThat(maskTypeFor(aKeyup), _isEqualTo(__TYPES.DEFINED))) __DEFINED_MASK.handleKeyupEvent(aKeyup);
    };
    var __handleChangeEvent = function (aChange) {
        handleMaskChangeEvent(aChange, findChangeHandlerFor(aChange));

        // nested ----------
        function handleMaskChangeEvent(aChange, aChangeEventHandler) {
            if (isRightThat(currentValueFor(aChange), _isNotEmpty())) {
                if (isRightThat(aChangeEventHandler, _isNotNull())) aChangeEventHandler(aChange);
            }
        }
        function findChangeHandlerFor(aChange) {
            switch (maskTypeFor(aChange)) {
                case __TYPES.IP:           return          handleIpAddressChangeEvent;
                case __TYPES.MAC_ADDRESS:  return         handleMacAddressChangeEvent;
                case __TYPES.PHONE_NUMBER: return        handlePhoneNumberChangeEvent;
                case __TYPES.EMAIL:        return      __EMAIL_MASK.handleChangeEvent;
                case __TYPES.USER_ID:      return    __USER_ID_MASK.handleChangeEvent;
                case __TYPES.DEFINED:      return    __DEFINED_MASK.handleChangeEvent;
                case __TYPES.INTEGER:      return    __INTEGER_MASK.handleChangeEvent;
                case __TYPES.CURRENCY:     return   __CURRENCY_MASK.handleChangeEvent;
                case __TYPES.DECIMAL:      return    __DECIMAL_MASK.handleChangeEvent;
                case __TYPES.DATE:         return       __DATE_MASK.handleChangeEvent;
                case __TYPES.DATE_RANGE:   return __DATE_RANGE_MASK.handleChangeEvent;
                default:                   return                                null;
            }
            // nested ----------
            function handleIpAddressChangeEvent(aChange) {return __getTextBox(aChange).value = __IP_ADDRESS_MASK.apply(currentValueFor(aChange));}
            function handleMacAddressChangeEvent(aChange) {return __getTextBox(aChange).value = __MAC_ADDRESS_MASK.apply(currentValueFor(aChange));}
            function handlePhoneNumberChangeEvent(aChange) {return __getTextBox(aChange).value = __PHONE_NUMBER_MASK.apply(currentValueFor(aChange));}
        }
    };
    var __testRegExps = function (arrayOfRegExps, testString) {
        for (var index = 0; index < arrayOfRegExps.length; index++) {
            if (arrayOfRegExps[index].test(testString)) return true;
        }
        return false;
    };
    // END   common private method ----------

    // BEGIN cross browsing private method ----------
    var __setEventHandler = function (textTypeHTMLInputElement, eventType, aEventHandler) {
        if (!("on" + eventType in textTypeHTMLInputElement)) throw new Error("ERROR : _MASK - setEventHandler.on" + eventType);

        if      ("addEventListener" in textTypeHTMLInputElement) /* Chrome */ textTypeHTMLInputElement.addEventListener(eventType, aEventHandler);
        else if ("attachEvent"      in textTypeHTMLInputElement) /* IE9    */ textTypeHTMLInputElement.attachEvent("on" + eventType, aEventHandler);
        else                                                  throw new Error("ERROR : _MASK - setEventHandler");
    };
    var __getTextBox = function (aEvent) {
        if ("target"     in aEvent) return aEvent.target;
        if ("srcElement" in aEvent) return aEvent.srcElement;

        throw new Error("ERROR : _MASK - getTextBox");
    };
    var __fireChangeEvent = function (textTypeHTMLInputElement) {
        if      ("createEvent"       in document) /* Chrome */ textTypeHTMLInputElement.dispatchEvent(createEvent());
        else if ("createEventObject" in document) /* IE9    */ textTypeHTMLInputElement.fireEvent("onchange");
        else                                                   throw new Error("ERROR : _MASK - fireChangeEvent");

        // nested ----------
        function createEvent() {
            var newEvent = document.createEvent("HTMLEvents");
            newEvent.initEvent("change", false, true);
            return newEvent;
        }
    };
    var __cancelEvent = function (aEvent) {
        if      ("preventDefault" in aEvent) /* IE10 */ aEvent.preventDefault();
        else if ("returnValue"    in aEvent)            aEvent.returnValue = false;
        else                                            throw new Error("ERROR : _MASK - cancelEvent");
    };
    var __focusTextBoxFor = function (aEvent, isAtFirst) {
        var textTypeHTMLInputElement = __getTextBox(aEvent);
        var position = (isRightThat(isAtFirst, _isEqualTo(true)) ? 0 : textTypeHTMLInputElement.value.length);

        if ("setSelectionRange" in textTypeHTMLInputElement) { /* Chrome */
            __IS_NO_SELECT = true;
            textTypeHTMLInputElement.focus();
            textTypeHTMLInputElement.setSelectionRange(position, position);
        } else
        if ("createTextRange" in textTypeHTMLInputElement) { /* IE9 */
            var aRange = textTypeHTMLInputElement.createTextRange();
            aRange.collapse(true);
            aRange.moveEnd("character", position);
            aRange.moveStart("character", position);
            aRange.select();
        } else {
            throw new Error("ERROR : _MASK - focusTextBoxFor");
        }
    };
    // END   cross browsing private method ----------

    // nested ----------
    function isRightThat(actual, aMatcher) {
        return findFunction(aMatcher.aFunction).apply(null, aArgumentFor(actual, aMatcher));
        // nested ----------
        function findFunction(functionName) {
            switch (functionName) {
                case "notEqualTo"  : return notEqualTo;
                case "notNullValue": return notNullValue;
                case "notAllOf"    : return notAllOf;
                case "has"         : return has;
                case "notEmpty"    : return notEmpty;
                case "between"     : return between;
                case "aMultipleOf" : return aMultipleOf;
                case "contains"    : return contains;
                default            : return eval(functionName);
            }
        }
        function aArgumentFor(actual, aPredicate) {
            var result = (Array.isArray(aPredicate.aArgument) ? aPredicate.aArgument : []);
            result.unshift(actual)
            return result;
        }
        function equalTo(actual, aOperand) {return (actual === aOperand);}
        function notEqualTo(actual, aOperand) {return !equalTo(actual, aOperand);}
        function nullValue(actual) {return (actual == null);}
        function notNullValue(actual) {return !nullValue(actual);}
        function anyOf(actual, arrayOfOperand) {
            for (var index = 0; index < arrayOfOperand.length; index++) {
                if (equalTo(actual, arrayOfOperand[index])) return true;
            }
            return false;
        }
        function notAllOf(actual, arrayOfOperand) {return !anyOf(actual, arrayOfOperand);}
        function has(actual, child) {return (isRightThat(actual, _isNotNull()) && isRightThat(child, _isNotNull()) && child in actual);}
        function empty(actual) {return (isRightThat(actual, _isNull()) || isRightThat(actual.length, _isEqualTo(0)));}
        function notEmpty(actual) {return !empty(actual);}
        function greaterThan(actual, number) {return (actual > number);}
        function notGreaterThan(actual, number) {return !greaterThan(actual, number);}
        function lessThan(actual, number) {return (actual < number);}
        function notLessThan(actual, number) {return !lessThan(actual, number);}
        function between(actual, min, max) {return (notLessThan(actual, min) && notGreaterThan(actual, max));}
        function contains(actual, substring) {return (null != actual && null != substring && 0 <= actual.indexOf(substring));}
        function aMultipleOf(actual, number) {
            if (isNaN(number) || isRightThat(number, _isEqualTo(0))) return false;
            if (isRightThat(number.toString(), _contains("."))) {
                var multiple = Math.pow(10, number.toString().split(".")[1].length)
                return isRightThat(Math.round(actual * multiple) % Math.round(number * multiple), _isEqualTo(0));
            } else {
                return isRightThat(actual % number, _isEqualTo(0));
            }
        }
    }
    function _isEqualTo(aOperand) {return {"aFunction": "equalTo", "aArgument": [aOperand]};}
    function _isNotEqualTo(aOperand) {return {"aFunction": "notEqualTo", "aArgument": [aOperand]};}
    function _isNull() {return {"aFunction": "nullValue"};}
    function _isNotNull() {return {"aFunction": "notNullValue"};}
    function _isAnyOf(arrayOfOperand) {return {"aFunction": "anyOf", "aArgument": [arrayOfOperand]};}
    function _isNotAllOf(arrayOfOperand) {return {"aFunction": "notAllOf", "aArgument": [arrayOfOperand]};}
    function _has(child) {return {"aFunction": "has", "aArgument": [child]};}
    function _isNotEmpty() {return {"aFunction": "notEmpty"};}
    function _isGreaterThan(number) {return {"aFunction": "greaterThan", "aArgument": [number]};}
    function _isNotGreaterThan(number) {return {"aFunction": "notGreaterThan", "aArgument": [number]};}
    function _isLessThan(number) {return {"aFunction": "lessThan", "aArgument": [number]};}
    function _isNotLessThan(number) {return {"aFunction": "notLessThan", "aArgument": [number]};}
    function _isBetween(min) {return {and: function (max) {return {"aFunction": "between", "aArgument": [min, max]}}};}
    function _contains(substring) {return {"aFunction": "contains", "aArgument": [substring]};}
    function _isAMultipleOf(number) {return {"aFunction": "aMultipleOf", "aArgument": [number]};}
    function isTrueThat(one) {
        return {
            isInteger:      function () {return __testRegExps([/^0$/, /^-?[1-9][0-9]*$/, /^-$/], one);}, /* [0, 양수/음수, -] */
            isNotInteger:   function () {return !isTrueThat(one).isInteger()},
            isNumber:       function () {return /^\d*$/.test(one);},
            isNumberString: function () {return isRightThat(one, _isEqualTo(Number(one).toString()));},
            isInRangeFor:   function (aEvent) {
                if (isNumber(one)) {
                    return isRightThat(one, _isBetween(minNumberFor(aEvent)).and(maxNumberFor(aEvent)));
                } else { /* string */
                    var length = one.length;
                    return isRightThat(one, _isBetween(minAttributeFor(aEvent).substr(0, length))
                        .and(maxAttributeFor(aEvent).substr(0, length)));
                }
                // nested ----------
                function isNumber(one) {return ("number" === (typeof one));}
            },

            isAKeyWithCtrlKey: function () {return isA(one.key) && isWithCtrlOnly(one);},
            isCKeyWithCtrlKey: function () {return isC(one.key) && isWithCtrlOnly(one);},
            isVKeyWithCtrlKey: function () {return isV(one.key) && isWithCtrlOnly(one);},
            isXKeyWithCtrlKey: function () {return isX(one.key) && isWithCtrlOnly(one);},
            isBackspaceKeyOnly: function () {return isBackspace(one.key) && isWithoutModifier(one);},
            isNumberKeyOnly: function () {return isNumber(one.key);},
            isDotKeyOnly: function () {return isDot(one.key) || isKeypadDot(one.key);},
            isBetween6KeyAnd9KeyOnly: function () {return isBetween6And9(one.key);},
            isBetweenAKeyAndFKeyOnly: function () {return isBetweenAAndF(one.key);},
            isBetweenAKeyAndFKeyWithShiftKey: function () {return isBetweenAAndF(one.key);},
            isHyphenKeyOnly: function () {return isHyphen(one.key) || isKeypadHyphen(one.key);},
            isColonKeyOnly:  function () {return isColon(one.key);},
            isPlusKeyOnly:   function () {return isPlusKey(one.key) || isKeypadPlus(one.key);},
            isUpKeyOnly:     function () {return isUp(one.key);},
            isDownKeyOnly:   function () {return isDown(one.key);},
            isZeroKeyOnly:   function () {return isZero(one.key);},
            isAlphabetUpperCaseKeyOnly: function () {return isAlphabetUpperCase(one.key);},
            isAllowedKeys:  function () {return isAllowedKeys(one.key);}
        };
        // nested ----------
        function isA(key) {return (null != key && isRightThat(key.toUpperCase(), _isEqualTo("A")));}
        function isC(key) {return (null != key && isRightThat(key.toUpperCase(), _isEqualTo("C")));}
        function isV(key) {return (null != key && isRightThat(key.toUpperCase(), _isEqualTo("V")));}
        function isX(key) {return (null != key && isRightThat(key.toUpperCase(), _isEqualTo("X")));}
        function isBackspace(key) {return isRightThat(key, _isEqualTo("Backspace"));}
        function isWithCtrlOnly(aKeydown) {return aKeydown.ctrlKey && !aKeydown.altKey && !aKeydown.shiftKey;}
        function isWithoutModifier(aKeydown) {return !aKeydown.ctrlKey && !aKeydown.altKey && !aKeydown.shiftKey;}
        function isNumber(key) {return isRightThat(key, _isAnyOf(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]));}
        function isDot(key) {return isRightThat(key, _isEqualTo("."));}
        function isKeypadDot(key) {return isRightThat(key, _isEqualTo("Decimal"));}
        function isBetween6And9(key) {return isRightThat(key, _isAnyOf(["6", "7", "8", "9"]));}
        function isBetweenAAndF(key) {return isRightThat(key.toUpperCase(), _isAnyOf(["A", "B", "C", "D", "E", "F"]));}
        function isHyphen(key) {return isRightThat(key, _isEqualTo("-"));}
        function isKeypadHyphen(key) {return isRightThat(key, _isEqualTo("Subtract"));}
        function isKeypadPlus(key) {return isRightThat(key, _isEqualTo("Add"));}
        function isColon(key) {return isRightThat(key, _isEqualTo(":"));}
        function isPlusKey(key) {return isRightThat(key, _isEqualTo("+"));}
        function isUp(key)   {return isRightThat(key, _isAnyOf(["ArrowUp", "Up"]));}
        function isDown(key) {return isRightThat(key, _isAnyOf(["ArrowDown", "Down"]));}
        function isZero(key) {return isRightThat(key, _isEqualTo("0"));}
        function isAlphabetUpperCase(key) {return isRightThat(key, _isAnyOf([
            "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "", "Z"
        ]));}
        function isAllowedKeys(key) {return isRightThat(key, _isAnyOf([
            "Tab",
            "Enter",
            "Shift",
            "Control",
            "Alt",
            "CapsLock",
            "HanjaMode", "KanjiMode",
            "KanaMode", /* 한/영 */
            "Escape", "Esc",
            "Meta", "Win",
            "ContextMenu", "Apps",
            "F1", /* 도움말 */
            "F5", /* 새로고침 */
            "F6", /* 주소창 */
            "F11", /* 전체화면 */
            "F12", /* 개발자도구 */
            "NumLock",
            "ScrollLock", "Scroll"
        ]));}
    }
    function currentValueFor(aEvent) {return __getTextBox(aEvent).value;}
    function maskTypeFor(aEvent) {return __getTextBox(aEvent).getAttribute(__NAMES.TYPE);}
    function removeFirstZeroIfNeeded(aKeydown) {
        if ((isRightThat(currentValueFor(aKeydown), _isEqualTo("0")) && (!isTrueThat(aKeydown).isZeroKeyOnly())) ||
            (isTrueThat(currentValueFor(aKeydown)).isNotInteger() && ( isTrueThat(currentValueFor(aKeydown)).isNumber()))
        ) {
            __getTextBox(aKeydown).value = currentValueFor(aKeydown).replace(/^0*/, "");
        }
    }
    function minMultipleOfStepFor(aKeydown) {
        if (isRightThat(maskTypeFor(aKeydown), _isEqualTo(__TYPES.DECIMAL))) {
            var multiple = Math.pow(10, fractionDigitsNumberFor(aKeydown));
            return (Math.round(minNumberFor(aKeydown) * multiple) - Math.round(minNumberFor(aKeydown) * multiple) % Math.round(stepNumberFor(aKeydown) * multiple)) / multiple;
        } else {
            return minNumberFor(aKeydown) - minNumberFor(aKeydown) % stepNumberFor(aKeydown);
        }
    }
    function maxMultipleOfStepFor(aKeydown) {
        if (isRightThat(maskTypeFor(aKeydown), _isEqualTo(__TYPES.DECIMAL))) {
            var multiple = Math.pow(10, fractionDigitsNumberFor(aKeydown));
            return (Math.round(maxNumberFor(aKeydown) * multiple) - Math.round(maxNumberFor(aKeydown) * multiple) % Math.round(stepNumberFor(aKeydown) * multiple)) / multiple;
        } else {
            return maxNumberFor(aKeydown) - maxNumberFor(aKeydown) % stepNumberFor(aKeydown);
        }
    }
    function minAttributeFor(aEvent) {return __getTextBox(aEvent).getAttribute(__NAMES.MIN);}
    function maxAttributeFor(aEvent) {return __getTextBox(aEvent).getAttribute(__NAMES.MAX);}
    function minNumberFor(aEvent) {return Number(minAttributeFor(aEvent));}
    function maxNumberFor(aEvent) {return Number(maxAttributeFor(aEvent));}
    function stepNumberFor(aEvent) {return Number(__getTextBox(aEvent).getAttribute(__NAMES.STEP));}
    function fractionDigitsNumberFor(aEvent) {return Number(__getTextBox(aEvent).getAttribute(__NAMES.FRACTION_DIGITS));}
    function extractValueFrom(input, aPredicate) { /* 앞에서 부터 1자리씩 잘라 유효한 값을 조립한다. */
        var output = "";
        var test;
        for (var index = 0; index < input.length; index++) {
            test = output + input.charAt(index);
            if (aPredicate(test)) output = test;
        }
        return output;
    }
    function slicedValueFor(aChange, aOperator, length) {
        if (isRightThat(length, _isNull())) return aOperator(currentValueFor(aChange));
        else                                return aOperator(currentValueFor(aChange)).substr(0, length);
    }
    function changeValue(aKeydown, aValue) {
        __getTextBox(aKeydown).value = aValue.toString();
        __fireChangeEvent(__getTextBox(aKeydown));
    }
    function doNothing(aEvent, callback) {
        __cancelEvent(aEvent);
        if (null != callback) callback();
    }
    function allowInputAtLast(aKeydown) {__focusTextBoxFor(aKeydown);}
    function allowInputAtFirst(aKeydown) {__focusTextBoxFor(aKeydown, true);}
    function charsAttributeFor(aEvent) {return __getTextBox(aEvent).getAttribute(__NAMES.DEFINED_CHARS);}
    function caseAttributeFor(aEvent) {return __getTextBox(aEvent).getAttribute(__NAMES.DEFINED_CASE);}
    function stringFromKey(aKeydown) {return (isTrueThat(aKeydown).isHyphenKeyOnly() ? "-" : aKeydown.key);}
    function notify(message, string1, string2) {
        var newMessage = message;
        if (null != string1) {
            newMessage = message.replace("%s", string1);
            if (null != string2) newMessage = newMessage.replace("%s", string2);
        }

        if ("_TOAST" in window) {
            if ("error" in _TOAST) {
                _TOAST.error(newMessage, {"preventDuplicates": true});
            }
        } else
        if ("console" in window) {
            if ("log" in console) {
                console.log(newMessage);
            }
        }
    }
    function isDate(input) {
        if (__testRegExps([/^[1-9]$/,                         /* 1~9 */
                           /^(19|[2-9]\d)\d{0,2}$/,                        /* 20~99, 190~999, 1900~9999 */
                           /^(19|[2-9]\d)\d{2}-(0[1-9]?|1[0-2]?)?$/,       /* 1900-~9999-, 1900-0~9999-1, 1900-01~9999-12 */
                           /^(19|[2-9]\d)\d{2}-(0[1-9]|1[0-2])-$/], input) /* 1900-01-~9999-12- */
        ) {
            return true;
        } else
        if (/^(19|[2-9]\d)\d{2}-(0[1-9]|1[0-2])-(0[1-9]?|1\d?|2\d?|3[01]?)$/.test(input)) { /* 1900-01-0~9999123, 19000101~99991231 */
            var endDate = (new Date(parseInt(input.split("-")[0], 10), parseInt(input.split("-")[1], 10), 0)).getDate();
            switch (endDate) {
                case 31: return true;
                case 30: return /^\d{4}-\d{2}-(0[1-9]?|1[0-9]?|2[0-9]?|30?)$/.test(input); /* YYYY-01-0~YYYY-MM-3, YYYY-01-01~YYYY-MM-30 */
                case 29: return /^\d{4}-\d{2}-(0[1-9]?|1[0-9]?|2[0-9]?)$/.test(input);     /* YYYY-01-0~YYYY-MM-2, YYYY-01-01~YYYY-MM-29 */
                case 28: return /^\d{4}-\d{2}-(0[1-9]?|1[0-9]?|2[0-8]?)$/.test(input);     /* YYYY-01-0~YYYY-MM-2, YYYY-01-01~YYYY-MM-28 */
                default: return false;
            }
        } else {
            return false;
        }
    }
    function addDays(input, days) {
        var dateOfInput = createDate(input);
        dateOfInput.setDate(dateOfInput.getDate() + days);
        return getStringFor(dateOfInput);
        // ----------
        function createDate(string) {
            var parts = string.split("-");
            return new Date(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1,
                parseInt(parts[2], 10));
        }
        function getStringFor(aDate) {
            return aDate.getFullYear().toString() + "-" + padStart(aDate.getMonth() + 1) + "-" +
                padStart(aDate.getDate());
        }
        function padStart(input) {
            var newInput = ("00" + input.toString());
            return newInput.substr(newInput.length - 2, 2);
        }
    }

    // public ------------------------------------------------------------------------------------------------------
    return {
        // public property
        TYPES: __TYPES,

        /**
         * @memberOf module:_MASK
         * @description MAC 주소 구분자(기본값: 0) 참고) 0.-, 1,:
         * @example <caption>HTML:</caption>
         * <input type="text" id="macAddress1" />
         * @example <caption>JAVAScript:</caption>
         * var macAddress1 = document.getElementById("macAddress1");
         * _MASK.MAC_ADDRESS_DELIMITER = 1;
         * _MASK.initialize(macAddress1, _MASK.TYPES.MAC_ADDRESS);
         */
        MAC_ADDRESS_DELIMITER: __macAddressDelimiter, /* 0 -> - *//* 1 -> : */

        /**
         * @memberOf module:_MASK
         * @property {string} [NUMBER="숫자"] 숫자
         * @property {string} [ALPHABET="알파벳"] 알파벳
         * @property {string} [KRW="금액(원)"] 금액(원)
         * @property {string} [KOREAN="한글"] 한글
         * @property {string} [DOT="."] .
         * @property {string} [ALPHABET_UPPER_CASE="알파벳대문자"] 알파벳대문자
         * @property {string} [SUPPORTED="다음 형식의 값만 입력이 가능합니다. : %s"] - 다음 형식의 값만 입력이 가능합니다. : %s
         * @property {string} [EXCEEDED="다음 범위의 값만 입력이 가능합니다. : %s"] 다음 범위의 값만 입력이 가능합니다. : %s
         * @property {string} [NOT_ENOUGH="다음 키는 %s 값을 채워야 입력이 가능합니다. : %s"] 다음 키는 %s 값을 채워야 입력이 가능합니다. : %s
         * @property {string} [ALLOWED="다음 키만 입력이 가능합니다. : %s"] 다음 키만 입력이 가능합니다. : %s
         * @property {string} [NOT_ALLOWED="다음 키만 입력이 불가능합니다. : %s"] 다음 키만 입력이 불가능합니다. : %s
         * @property {string} [CAPS_LOCK="'Caps Lock' 키가 켜져 있습니다."] 'Caps Lock' 키가 켜져 있습니다.
         * @description 메시지
         * @example
         * _MASK.MESSAGES.CAPS_LOCK = "The 'Caps Lock' key is on.";
         */
        MESSAGES: {
            NUMBER: "숫자",
            ALPHABET: "알파벳",
            KRW: "금액(원)",
            KOREAN: "한글",
            DOT: ".",
            UNDER_BAR: "_",
            HYPHEN: "-",
            ALPHABET_UPPER_CASE: "알파벳대문자",
            SUPPORTED: "다음 형식의 값만 입력이 가능합니다. : %s",
            EXCEEDED: "다음 범위의 값만 입력이 가능합니다. : %s",
            NOT_ENOUGH: "다음 키는 %s 값을 채워야 입력이 가능합니다. : %s",
            ALLOWED: "다음 키만 입력이 가능합니다. : %s",
            NOT_ALLOWED: "다음 키만 입력이 불가능합니다. : %s",
            CAPS_LOCK: "'Caps Lock' 키가 켜져 있습니다."
        },

        // public method

        /**
         * @description text 타입의 HTMLInputElement 에 입력값을 제한하는 mask 를 설정한다.
         * @example <caption>HTML:</caption>
         * <input type="text" id="email1" />
         * @example <caption>JAVAScript:</caption>
         * var email1 = document.getElementById("email1");
         * _MASK.initialize(email1, _MASK.TYPES.EMAIL);
         * @param {HTMLElement} textTypeHTMLInputElement mask 를 설정할 대상 객체
         * @param {module:_MASK~TYPES} maskType 타입
         * @param {{}} [aOption] JSON 타입의 부가정보
         * @param {number} aOption.min 최소값
         * @param {number} aOption.max 최대값
         * @param {number} aOption.step 증가/감소단위
         * @param {string} aOption.chars 입력 가능한 문자 ex.) "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
         * @param {string} aOption.case 대/소문자 입력 제한 ex.) "upper", "lower"
         */
        initialize: function (textTypeHTMLInputElement, maskType, aOption) {
            if (isSureThat(maskType, _isNotValid())) throw new Error("ERROR : The type value is not valid.");
            if (isRightThat(textTypeHTMLInputElement.type, _isNotEqualTo("text"))) {
                if (isRightThat(textTypeHTMLInputElement.type, _isEqualTo("number"))) {
                    console.log("The input element's type ('number') does not support selection: element.type = number -> text");
                } else {
                    console.log("element.type = text");
                }
                textTypeHTMLInputElement.type = "text";
            }

            addEventHandlersIfNeeded(textTypeHTMLInputElement);
            setAttributes(textTypeHTMLInputElement, maskType, aOption);
            applyMaskToCurrentValue(textTypeHTMLInputElement);

            // nested ----------
            function isSureThat(actual, aMatcher) {
                return findFunction(aMatcher.aFunction).apply(null, aArgumentFor(actual, aMatcher));
                // nested ----------
                function findFunction(functionName) {
                    switch (functionName) {
                        case "notValid"          : return notValid;
                        case "hasNoEventHandlers": return hasNoEventHandlers;
                        default                  : return eval(functionName);
                    }
                }
                function aArgumentFor(actual, aPredicate) {
                    var result = (Array.isArray(aPredicate.aArgument) ? aPredicate.aArgument : []);
                    result.unshift(actual)
                    return result;
                }
                function notValid() {
                    for (var typeKey in __TYPES) {
                        if (isRightThat(actual, _isEqualTo(__TYPES[typeKey]))) return false;
                    }
                    return true;
                }
                function hasEventHandlers(actual) {return actual.hasAttribute(__NAMES.TYPE);}
                function hasNoEventHandlers(actual) {return !hasEventHandlers(actual);}
            }
            function _isNotValid() {return {"aFunction": "notValid"};}
            function _hasEventHandlers() {return {"aFunction": "hasEventHandlers"};}
            function _hasNoEventHandlers() {return {"aFunction": "hasNoEventHandlers"};}
            function setAttributes(textTypeHTMLInputElement, maskType, aOption) {
                textTypeHTMLInputElement.setAttribute(__NAMES.TYPE, maskType);
                if (isRightThat(maskType, _isAnyOf([__TYPES.INTEGER, __TYPES.CURRENCY]))) {
                    var defaultMinOption = (isRightThat(maskType, _isEqualTo(__TYPES.INTEGER)) ? __INTEGER_MASK.RANGE.MIN : 0);
                    textTypeHTMLInputElement.setAttribute(__NAMES.MIN, minOptionNumberInRangeFor(aOption, defaultMinOption));
                    textTypeHTMLInputElement.setAttribute(__NAMES.MAX,  maxOptionNumberInRangeFor(aOption, __INTEGER_MASK.RANGE.MAX));
                    textTypeHTMLInputElement.setAttribute(__NAMES.STEP, stepOptionNumberInRangeFor(aOption));
                } else
                if (isRightThat(maskType, _isEqualTo(__TYPES.DECIMAL))) {
                    var fraction = Math.pow(10, fractionDigitsOptionInRangeFor(aOption));
                    textTypeHTMLInputElement.setAttribute(__NAMES.FRACTION_DIGITS, fractionDigitsOptionInRangeFor(aOption));
                    textTypeHTMLInputElement.setAttribute(__NAMES.MIN, minOptionNumberInRangeFor(aOption, 0, fraction));
                    textTypeHTMLInputElement.setAttribute(__NAMES.MAX, maxOptionNumberInRangeFor(aOption, 100, fraction));
                    textTypeHTMLInputElement.setAttribute(__NAMES.STEP, stepOptionNumberInRangeFor(aOption, fraction));
                } else
                if (isRightThat(maskType, _isEqualTo(__TYPES.DATE))) {
                    textTypeHTMLInputElement.setAttribute(__NAMES.MIN, minDateInRangeFor(aOption));
                    textTypeHTMLInputElement.setAttribute(__NAMES.MAX, maxDateInRangeFor(aOption));
                } else
                if (isRightThat(maskType, _isEqualTo(__TYPES.DATE_RANGE))) {
                    textTypeHTMLInputElement.setAttribute(__NAMES.MIN, minDateInRangeFor(aOption));
                    textTypeHTMLInputElement.setAttribute(__NAMES.MAX, maxDateInRangeFor(aOption));
                } else
                if (isRightThat(maskType, _isEqualTo(__TYPES.DEFINED))) {
                    textTypeHTMLInputElement.setAttribute(__NAMES.DEFINED_CHARS, charsFor(aOption));
                    textTypeHTMLInputElement.setAttribute(__NAMES.DEFINED_CASE, caseFor(aOption));
                }
                // nested ----------
                function minOptionNumberInRangeFor(aOption, defaultOption, fraction) {
                    if (isRightThat(fraction, _isNull())) {
                        return Math.min(__INTEGER_MASK.RANGE.MAX, Math.max(__INTEGER_MASK.RANGE.MIN, minOptionNumberFor(aOption, defaultOption)));
                    } else {
                        return Math.min(__INTEGER_MASK.RANGE.MAX / fraction, Math.max(__INTEGER_MASK.RANGE.MIN / fraction, minOptionNumberFor(aOption, defaultOption)));
                    }
                }
                function maxOptionNumberInRangeFor(aOption, defaultOption, fraction) {
                    if (isRightThat(fraction, _isNull())) {
                        return Math.min(__INTEGER_MASK.RANGE.MAX, Math.max(__INTEGER_MASK.RANGE.MIN, maxOptionNumberFor(aOption, defaultOption)));
                    } else {
                        return Math.min(__INTEGER_MASK.RANGE.MAX / fraction, Math.max(__INTEGER_MASK.RANGE.MIN / fraction, maxOptionNumberFor(aOption, defaultOption)));
                    }
                }
                function minDateInRangeFor(aOption) {
                    return minString(["9999-12-31", maxString(["1900-01-01", minDateOptionFor(aOption, "1900-01-01")])]);
                    // nested ----------
                    function minDateOptionFor(aOption, defaultOption) {
                        var dateOption = minOptionFor(aOption, defaultOption);
                        return (10 === dateOption.length ? dateOption : defaultOption);
                    }
                }
                function maxDateInRangeFor(aOption) {
                    return minString(["9999-12-31", maxString(["1900-01-01", maxDateOptionFor(aOption, "9999-12-31")])]);
                    // nested ----------
                    function maxDateOptionFor(aOption, defaultOption) {
                        var dateOption = maxOptionFor(aOption, defaultOption);
                        return (10 === dateOption.length ? dateOption : defaultOption);
                    }
                }
                function stepOptionNumberInRangeFor(aOption, fraction) {
                    if (isRightThat(fraction, _isNull())) {
                        return Math.min(__INTEGER_MASK.RANGE.MAX, Math.max(1, stepOptionNumberFor(aOption)));
                    } else {
                        return Math.min(__INTEGER_MASK.RANGE.MAX / fraction, Math.max(1 / fraction, stepOptionNumberFor(aOption, fraction)));
                    }
                }
                function fractionDigitsOptionInRangeFor(aOption) {
                    return Math.min(14, Math.max(1, fractionDigitsOptionNumberFor(aOption)));
                }
                function minOptionFor(aOption, defaultOption) {return (isRightThat(aOption, _has("min")) ? aOption["min"] : defaultOption);}
                function maxOptionFor(aOption, defaultOption) {return (isRightThat(aOption, _has("max")) ? aOption["max"] : defaultOption);}
                function minOptionNumberFor(aOption, defaultOption) {return Number(minOptionFor(aOption, defaultOption));}
                function maxOptionNumberFor(aOption, defaultOption) {return Number(maxOptionFor(aOption, defaultOption));}
                function stepOptionNumberFor(aOption, fraction) {
                    if (isRightThat(fraction, _isNull())) {
                        return (isRightThat(aOption, _has("step")) ? Number(aOption["step"]) : 1);
                    } else {
                        return (isRightThat(aOption, _has("step")) ? Number(aOption["step"]) : 1 / fraction);
                    }
                }
                function fractionDigitsOptionNumberFor(aOption) {return (isRightThat(aOption, _has("fractionDigits")) ? Number(aOption["fractionDigits"]) : 2);}
                function minString(arrayOfString) {
                    var result = arrayOfString[0];
                    for (var index = 1; index < arrayOfString.length; index++) {
                        if (arrayOfString[index] < result) result = arrayOfString[index];
                    }
                    return result;
                }
                function maxString(arrayOfString) {
                    var result = arrayOfString[0];
                    for (var index = 1; index < arrayOfString.length; index++) {
                        if (arrayOfString[index] > result) result = arrayOfString[index];
                    }
                    return result;
                }
                function charsFor(aOption) {
                    return (null != aOption && null != aOption["chars"] && 0 < aOption["chars"].toString().length ? aOption["chars"].toString() : "");
                }
                function caseFor(aOption) {
                    return (null != aOption && null != aOption["case"] && 0 < aOption["case"].toString().length ? aOption["case"].toString() : "");
                }
            }
            function addEventHandlersIfNeeded(textTypeHTMLInputElement) {
                if (isSureThat(textTypeHTMLInputElement, _hasNoEventHandlers())) {
                    __setEventHandler(textTypeHTMLInputElement, "contextmenu", __handleContextmenuEvent);
                    __setEventHandler(textTypeHTMLInputElement, "select"     , __handleSelectEvent     );
                    __setEventHandler(textTypeHTMLInputElement, "keydown"    , __handleKeydownEvent    );
                    __setEventHandler(textTypeHTMLInputElement, "keyup"      , __handleKeyupEvent      );
                    __setEventHandler(textTypeHTMLInputElement, "change"     , __handleChangeEvent     );
                }
            }
            function applyMaskToCurrentValue(textTypeHTMLInputElement) {
                if (isSureThat(textTypeHTMLInputElement, _hasEventHandlers())) __fireChangeEvent(textTypeHTMLInputElement);
            }
        },
    };
})(window, document);
})(window, document); /* (function () { */